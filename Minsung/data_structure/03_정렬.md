# 03. 정렬

## 01. 버블 정렬

정렬 방법 : 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 끝부터 정렬하는 방식

``` C++
void bubbleSort(vector<int> v)
{
    for (int i = 0; i < v.size(); i++)
    {
        for (int j = 0; j < v.size() - i - 1; j++)
        {
            if (v[j] > v[j + 1])
                swap(v[j], v[j + 1]);
        }
    }
}
```



## 02. 선택 정렬

정렬 방법 : 먼저 주어진 리스트 중에 최소값을 찾고 그 값을 맨 앞에 위치한 값과 교체하는 방식

``` C++
void selectionSort(vector<int> v)
{
    vector<int>::iterator minLoc;
    vector<int>::iterator itr, itr2;

    for (itr = v.begin(); itr != v.end(); itr++)
    {
        minLoc = itr;

        for (itr2 = itr + 1; itr2 != v.end(); itr2++)
        {
            if (*itr2 < *minLoc)
                minLoc = itr2;
        }

        // swap
        swap(*itr, *minLoc);
    }
}
```



## 03. 삽입 정렬

정렬 방법 : 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여, 자신의 위치를 찾아 삽입하는 방식

``` C++
void insertionSort(vector<int> v)
{
    vector<int>::iterator itr;
    int save; // 이번 턴의 체크할 값

    for (itr = v.begin() + 1; itr != v.end(); ++itr)
    {
        save = *itr;
        vector<int>::iterator itr2 = itr;

        // 기존의 체크한 값들을 비교
        // save 보다 크면 하나씩 뒤로 민다
        // => save가 들어갈 위치를 찾는 과정
        while (itr2 != v.begin() && *(itr2 - 1) > save)
        {
            *itr2 = *(itr2 - 1);
            --itr2;
        }
        *itr2 = save;
    }
}
```



## 04. 합병 정렬

정렬 방법 : 작은 단위로 잘게 쪼개어 작은 단위부터 정렬해서 정렬된 단위들을 계속 병합해가면서 정렬하는 방식

``` C++
void merging(vector<int> &v, int left, int size, int right)
{
    vector<int> total;
    int i, j;

    i = left;     
    j = size + 1; 
    while (i <= size && j <= right)
    {
        if (v[i] > v[j])
            total.push_back(v[j++]);

        else
            total.push_back(v[i++]);
    }

    if (i > size)
    {
        while (j <= right)
            total.push_back(v[j++]);
    }
    else
    {
        while (i <= size)
            total.push_back(v[i++]);
    }

    for (int x = left; x <= right; x++)
        v[x] = total[x - left];
}

void divide(vector<int> &v, int left, int right)
{
    if (left >= right)
        return;

    int size = (left + right) / 2;

    divide(v, left, size);
    divide(v, size + 1, right);

    merging(v, left, size, right);
}

void mergeSort(vector<int> v)
{
    divide(v, 0, v.size() - 1);
}
```



## 05. 퀵 정렬

정렬 방법 : 하나의 축(Pivot)을 먼저 정하여 이 축의 값보다 작은 값은 왼쪽에 큰 값은 오른쪽으로 위치시킨뒤 왼쪽과 오른쪽의 수 들은 다시 각각의 축으로 나누어 정렬하는 방식

``` C++
int partition(vector<int> &v, int left, int right, int pivot)
{
    int i = left;
    int j = right - 1;

    while (i <= j)
    {
        while (i <= j && v[i] <= pivot)
            ++i;
        while (j >= i && v[j] >= pivot)
            --j;
        if (i < j)
            swap(v[i], v[j]);
    }
    
    // 피벗과 작동이 멈춘 i 위치 교환
    swap(v[i], v[right]);

    return i;
}

void quick(vector<int> &v, int left, int right)
{
    int Pi;

    if (left >= right)
        return;

    Pi = partition(v, left, right, v[right]);
    quick(v, left, Pi - 1);
    quick(v, Pi + 1, right);
}

inline void quickSort(vector<int> v)
{
    quick(v, 0, v.size() - 1);
}
 
```





## 06. 정렬 별 시간복잡도 및 공간복잡도

| 정렬 종류 | 평균 시간복잡도 | 최선 시간복잡도         | 최악 시간복잡도           | 공간 복잡도 |
| --------- | --------------- | ----------------------- | ------------------------- | ----------- |
| 버블 정렬 | O(n^2)          | O(n^2)                  | O(n^2)                    | O(n)        |
| 선택 정렬 | O(n^2)          | O(n^2)                  | O(n^2)                    | O(n^2)      |
| 삽입 정렬 | O(n^2)          | O(n) : 이미 정렬된 경우 | O(n^2)                    | O(n^2)      |
| 합병 정렬 | O(nlog n)       | O(nlog n)               | O(nlog n)                 | O(nlog n)   |
| 퀵 정렬   | O(nlog n)       | O(nlog n)               | O(n^2) : 이미 정렬된 경우 | O(nlog n)   |









## 레퍼런스

* https://unikys.tistory.com/357
* https://coding-factory.tistory.com/615

## 질문할 사항

* 선택 정렬 공간 복잡도가 왜 O(n^2)

  

## 추가 공부할 키워드

* 추가적인 정렬 방법들
* AVL 트리