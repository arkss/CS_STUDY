# 08. 교착상태

## 01. 교착상태란?

**교착상태(deadlock)**는 다음과 같이 정의할 수 있습니다.

한 프로세스들의 집합 내에서 각각의 프로세스가 그 집합 내의 다른 프로세스만이 발생시킬 수 있는 이벤트를 기다리고 있으면 그 집합의 프로세스들은 교착상태에 걸려있다고 할 수 있습니다.

대부분의 경우에는 각 프로세스가 기다리고 있는 이벤트는 다른 프로세스가 점유하고 있어 사용하지 못하는 자원이 반환되는 것입니다. 

여기서 자원이란 하드웨어와 소프트웨어를 총 망라하는 자원들을 의미합니다.

또한 이렇게 자원에 의해 일어나는 교착상태를 **자원 교착상태** 라고 합니다.



### 자원 교착상태의 조건

교착상태가 되기 위해서는 아래 4가지 조건이 만족해야 합니다.

1. mutual exclusion

   상호배제라고 하며 각 자원은 현재 정확하게 하나의 프로세스에게 할당되어 있거나 혹은 가용한 상태

2. hold and wait

   현재 자원을 보유하고 있는 프로세스가 새로운 자원을 요청

3. no preemption

   비선점이라고 하며 다른 프로세스의 자원을 강제로 빼았을 수 없음

4. circular wait

   둘 이상의 프로세스들의 순환 체인이 있어야 함

   



### 교착상태를 해결하기 위한 전략

1. 무시
2. 탐지 및 회복
3. 자원 할당을 조심하여 동적 회피
4. `자원 교착상태의 조건` 을 막아 예방





## 02. 교착상태를 해결하기 위한 전략(1) - 무시

교착상태를 해결하기 위한 첫 번째 전략은 **무시**하는 방법입니다.

이는 **타조 알고리즘**이라고도 하는데 타조가 머리를 모레에 처박고 아무런 문제가 없는 척 하는 것에서 따왔습니다.



## 03. 교착상태를 해결하기 위한 전략(2) - 탐지 및 회복

두 번째 전략은 **탐지와 회복**입니다.

이는 교착상태의 발생을 예방하려고 하지 않습니다.

다만 교착상태가 발생한 것을 검출하고 이를 회복하기 위해 노력합니다.



### 타입마다 자원이 하나인 경우 교착상태 탐지

각 타입마다 자원이 단 하나만 존재하는 경우, 자원과 프로세스에 대해 그래프를 만들 수 있습니다.

해당 그래프에서 사이클이 있다면 교착상태이고, 사이클이 없으면 교착상태가 아닙니다.



### 타입마다 자원이 다수인 경우 교착상태 탐지

https://m.blog.naver.com/PostView.nhn?blogId=doublebee1&logNo=220356473254&proxyReferer=https:%2F%2Fwww.google.com%2F



<br><br>

위와 같은 방법으로 교착상태를 탐지했다면 교착상태로 부터 회복해야합니다.

아래 3가지의 회복 방법이 있지만 매력적인 방법은 없습니다.

### 선점을 통한 회복

자원을 프로세스로 부터 회수하여 다른 프로세스에게 주는 방법입니다.

하지만 자원에 따라서 이러한 방식의 회복이 매우 어렵거나 불가능하기도 합니다.

이 때 어떤 프로세스로 부터 어떤 자원을 회수할 지에 대한 판단은 어떤  프로세스가 쉽게 돌려받을 수 있는 자원을 가지고 있느냐에 따라 다릅니다.



### 롤백을 통한 회복

교착상태로 부터 회복하기 위해 프로세스를 과거로 되돌리는 방법입니다.

과거로 되돌린다는 의미는 교착상태에 빠지게끔 하는 자원을 획득하기 전으로 롤백한다는 것을 의미합니다.

이를 위해 정기적으로 프로세스들을 체크포인팅하여 이것의 상태를 파일에 기록합니다.



### 프로세스 강제 종료를 통한 회복

가장 간단한 방법은 교착상태에 빠지게끔 하는 프로세스를 강제 종료하는 것입니다.

하나의 프로세스를 종료하여도 끝나지 않는다면 교착상태가 끝날 때까지 프로세스를 죽이게 됩니다.





## 04. 교착상태를 해결하기 위한 전략(3) - 회피

대부분의 시스템에서 프로세스는 자원을 한 번에 하나씩 요구합니다.

이 때 해당 자원을 할당하기 전 안전한지 확인할 수 있습니다.



### 은행원 알고리즘

| 프로세스 이름 | 보유 자원 수 | 작업을 마치기 위해 필요한 총 자원 수 |
| ------------- | ------------ | ------------------------------------ |
| A             | 3            | 9                                    |
| B             | 2            | 4                                    |
| C             | 2            | 7                                    |

남은 자원 수 : 3



위와 같은 상황을 봅시다.

남은 자원을 B가 먼저 할당받고 B가 끝난 후, 다시 남은 자원을 C, A 순으로 받으면 모든 프로세스가 문제 없이 작업을 완료할 수 있습니다.

하지만 남은 자원을 A가 먼저 할당받는다면 어떻게 될까요?

세 개의 프로세스가 모두 끝나지 않은 **교착상태**에 빠지게 됩니다.





따라서 은행원 알고리즘은 자원에 대한 요청이 들어오면 이를 승인했을 시, 안전한 상태에 도달하는지 검사합니다.

하지만 프로세스들이 자신의 최대 자원 요구량이 얼마나 될 지를 거의 알 수 없을 뿐더러 프로세스 수가 고정적이지 않고 사용자의 요청에 의해 계속 변하기 때문에 실제로 은행원 알고리즘을 사용하는 시스템은 거의 없습니다.





## 5. 교착상태를 해결하기 위한 전략(4) - 예방

예방을 하기위해서 앞에서 언급했던 `자원 교착상태의 조건`을 만족시키지 않도록 합니다.



### mutual exclusion

상호배제는 자원이 공유되지 않을 때 일어납니다. 만일 자원을 공유할 수 있다면 교착상태에 빠지지 않습니다.



### hold and wait

모든 프로세스들이 실행을 시작하기 전에 모든 자원을 요청합니다. 

만일 모든 자원을 할당 받을 수 있다면 할당받고 작업을 시작합니다.

자신의 작업에 필요한 모든 자원을 미리 할당받기 때문에 교착상태에 빠질 일이 없습니다.

하지만 프로세스들은 자신이 필요한 자원들을 정확히 알 수가 없습니다.

또한 이 경우 자원을 효율적으로 사용할 수 없습니다.



### no preemption

비선점인 자원을 선점으로 바꿔 프로세스가 강제로 뺏어올 수 있도록 합니다.



### circular wait

순환 대기를 막는 방법은 다양합니다.

* 첫 번째로 프로세스들이 하나의 자원을 사용하도록 합니다. 하나의 자원을 모두 사용했다면 반환하고 새로운 자원을 요청합니다.

* 두 번째로는 자원에 번호를 매기고 해당 번호의 오름차순으로만 자원을 요청하도록 합니다.

  번호가 큰 자원을 요청하고 그 다음으로 번호가 작은 자원을 요청하는 것을 막음으로서 순환 대기를 막을 수 있습니다.





## 레퍼런스

* 운영체제론

## 질문할 사항



## 추가 공부할 키워드

* 투페이스 락킹
* 통신 교착상태
* 라이브락
* 기아