# 06. 상호배제 방법

## 01. 들어가기 전에

들어가기 전에 몇 가지 단어들에 대해서 알아봅시다.

### 경쟁조건(race condition)

경쟁조건이란 둘 또는 그 이상의 프로세스가 공유 데이터를 읽거나 쓰는데 최종 결과가 누가 언제 수행되는가에 따라 달라지는 현상을 말합니다.



### 상호배제(mutual exclusion)

상호배제는 한 프로세스가 공유 변수나 파일을 사용 중이면 다른 프로세스들은 똑같은 일을 수행하지 못하도록 하는 것을 말합니다.



### 임계구역(critical region / critical section)

임계구역이란 공유 메모리에 접근하는 코드의 일부를 말합니다.



아래에서 상호배제를 위한 여러 가지 방법을 알아볼 것입니다.

좋은 상호배제가 되기 위해서는 아래의 조건을 만족해야 합니다.

1. 두 개의 프로세스가 동시에 자기의 임계구역 내에 존재하는 경우는 없어야 합니다.
2. CPU의 개수나 속도에 대해 어떤 가정도 하지 않습니다.
3. 임계구역 외부에서 실행하고 있는 프로세스는 다른 프로세스들을 블록시켜서는 안됩니다.
4. 임계구역에 진입하기 위해 무한히 기다리는 프로세스는 없어야 합니다.





## 02. 바쁜 대기를 이용한 상호배제

### 인터럽트 끄기

프로세스가 임계구역에 진입하자마자 인터럽트를 끄고 임계구역에서 나가기 직전에 인터럽트를 키는 방법입니다.

인터럽트를 끄면 문맥교환이 일어나지 않으므로 프로세스가 걱정없이 공유 메모리를 검사하고 변경할 수 있습니다.

하지만 아래와 같은 문제점이 존재합니다.

* 사용자 프로세스에게 인터럽트를 끌 수 있는 권한을 주는 것은 위험합니다. 인터럽트를 끈 후 다시 켜지 않는다면 문제가 발생합니다.
* CPU가 2개 이상인 경우에는 의미가 없어집니다. 인터럽트를 꺼서 해당 CPU의 다른 프로세스는 임계구역에 접근을 못하지만 다른 CPU의 프로세스가 접근하는 것을 막을 수 없습니다.



### 락 변수

락 변수를 사용하는 방법입니다.

변수의 값이 0이면 1로 바꾸고 임계구역에 진입하며, 나올 때 0으로 바꿉니다. 다른 프로세스들은 락 변수의 값이 1이면 임계구역에 접근하지 않고 대기합니다.

이도 문제점이 존재합니다.

* 락 변수에 대한 상호배제 문제가 발생합니다. 



### 엄격한 교대

아래는 엄격한 교대에 대한 수도코드입니다. 

프로세스 0은 turn 변수가 0이 될 때까지 대기하다가 임계구역에 진입하고, 나올 때 turn 변수를 1로 바꿔줍니다.

프로세스 1은 turn 변수가 1이 될 때까지 대기하다가 임계구역에 진입하고, 나올 때 turn 변수를 0로 바꿔줍니다.

```C
// 프로세스 0
while(true){
	while(turn!=0)
	critical_region();
	turn = 1;
	noncritical_region();
}

// 프로세스 1
while(true){
	while(turn!=1)
	critical_region();
	turn = 0;
	noncritical_region();
}
```

이 때 변수가 특정 값이 될 때까지 계속해서 검사하는 것을 **바쁜 대기(busy waiting)** 라고 합니다.

또한 바쁜 대기를 사용하는 락 변수, turn을 **스핀 락(spin lock)**이라고 합니다.



이 역시 문제점이 존재합니다.

두 프로세스의 속도가 차이가 클 경우를 가정해봅시다.

1. 프로세스 0이 임계구역을 마치고 turn 변수를 1로 설정
2. 프로세스 1이 임계구역을 마치고 turn 변수를 0으로 설정
3. 프로세스 0이 임계구역을 마치고 turn 변수를 1로 설정
4. 프로세스 1은` noncritical_region` 에서 수행중
5. 프로세스 0이 임계구역에 진입하고자 하지만 turn이 1이라 수행불가

이는 임계구역 밖에 있는 프로세스 1이 프로세스 0을 블록시키는 상황이므로 처음에 언급한 조건 3에 위배됩니다.





### Peterson의 해법

아래는 `Peterson`의 해법에 대한 코드입니다.

프로세스는 임계구역에 진입 시 자신의 프로세스 번호를 인자로 `enter_region` 를 호출하고, 작업을 마친 후 `leave_region` 을 호출 후 빠져나갑니다.

``` C
#define FALSE 0
#define TRUE 1
#define N 2 // 프로세스의 수

int turn;
int interested[N];

void enter_region(int process)
{
  int other;
  
  other = 1 - process;
  interested[process] = TRUE;
  turn = process;
  while (turn == process && interested[other] == TRUE)
}

void leave_region(int process)
{
  interested[process] = FALSE;
}
```



일반적인 경우, 프로세스 0이 임계구역에 있을 때, 프로세스 1은 `interested[0] == TRUE` 이므로 바쁜 대기를 수행합니다.

이번에는 두 프로세스가 거의 동시에 `enter_region` 에 진입하는 경우를 생각해봅시다.

프로세스 0이 조금 더 빨랐고 프로세스 1이 늦어 `turn` 변수에는 1이 담겨있습니다.

프로세스 0은 `turn == process` 이 false이므로 대기 없이 임계구역에 진입합니다.





## 3. sleep과 wakeup

### 우선순위 역전 문제

`Peterson의 해법` 은 특별한 문제가 발생하지는 않지만 바쁜 대기를 수행해야 한다는 단점이 있습니다.

바쁜 대기는 CPU의 시간을 낭비할 뿐 아니라 새로운 문제가 발생할 수 있습니다.

우선순위가 높은 프로세스 0가 낮은 프로세스 1이 있다고 가정합시다.

프로세스 1이 먼저 임계구역에 진입한 후, 프로세스 0이 준비상태가 되어 임계구역에 진입하기 위해 바쁜 대기를 수행합니다.

이 때 우선순위가 프로세스 0이 더 높으므로 프로세스 1은 임계구역을 벗어날 기회를 가지지 못하고 두 프로세스는 무한 루프에 빠지게 됩니다.

이러한 문제를 **우선순위 역전 문제**라고 합니다.



CPU가 시간을 낭비하는 바쁜 대기 대신 **sleep과 wakeup**에 대해 알아봅시다.



### 생산자 소비자 문제

**sleep과 wakeup**가 사용되는 예제로 생산자 소비자 문제를 봅시다.

생산자와 소비자가 버퍼를 공유하고 생산자는 정보를 버퍼에 저장하고 소비자는 정보를 버퍼에서 꺼내옵니다.

버퍼의 크기는 유한하기 때문에 버퍼가 가득차있으면 문제가 발생합니다. 

이 때 생산자는 버퍼가 가득차있다면 sleep을 하고, 소비자가 정보를 버퍼에서 꺼내온 순간 생산자를 wakeup 해줍니다.

반대의 상황에서는 버퍼가 비어있으면 소비자는 sleep하고 생산자는 정보를 버퍼에 넣는 순간 소비자를 wakeup 해줍니다.

이에 대한 코드입니다.

``` C
#define N 100 // 버퍼의 크기
int count = 0;

void producer(void)
{
  int item;
  
  while(true){
    item = produce_item();
    if (count == N) sleep();
    insert_item(item);
    count++;
    if (count == 1) wakeup(consumer);
  }
}

void consumer(void)
{
  int item;
  
  while(true){
		if (count == 0) sleep();
    item = remove_item();
    count--;
    if (count == N-1) wakeup(producer);
    consume_item(item);
  } 
}
```



아쉽게도 `count`에 대한 경쟁조건이 발생합니다.

1. 버퍼가 비어있을 때 소비자가 count값 0을 읽음
2. 소비자 -> 생산자로 문맥교환 발생
3. 생산자가 정보를 버퍼에 저장하고 count 값을 1로 갱신
4. 생산자가 소비자에서 wakeup 호출
5. 소비자가 아직 잠들어있지 않으므로 wakeup 무시
6. 생산자 -> 소비자로 문맥교환 발생
7. 소비자는 아까 읽은 count값 0을 보고 sleep



생산자도 시간이 지남에 따라 sleep하게 되고 서로 깨워주지 못하고 무한히 잠들게 됩니다.



### wakeup waiting 비트

위에서 `count`에 대한 경쟁조건으로 wakeup이 소실되었습니다.

wakeup을 소실되지만 않는다면 문제가 해결됩니다.

이를 위해 **wakeup waiting 비트**을 사용해봅시다.

프로세스에게 wakeup이 전송될 때 프로세스가 꺠어 있다면 wakeup waiting 비트를 설정합니다.

그리고 나중에 프로세스가 잠들려고 할 때 이 비트가 설정되어 있다면 이 비트를 지우고 잠들지 않습니다.

하지만 프로세스가 여러 개라면 wakeup waiting 비트 하나로는 처리할 수 없으며 해당 비트의 수를 늘리는 것은 근본적인 해결책이 아닙니다.



### 세마포어

**세마포어**는 정수변수로서 미래를 위해 미리 호출한 wakeup을 저장해놓는 역할을 합니다.

세마포어의 값이 0일 때는 wakeup이 저장되어있지 않고, 1이상일 경우에는 wakeup을 저장하고 있음을 의미합니다.

또한 **down과 up**, 두 개의 개념을 도입합니다.

* down

  세마포어의 값이 0보다 크면 세마포어 값을 하나 감소시킵니다.

  세마포어의 값이 0이라면 down 수행을 완료하지 않고 즉시 잠들게 됩니다.

* up

  세마포어의 값이 0보다 크거나 같고 잠들어 있는 프로세스가 없다면 세마포어의 값을 하나 증가시킵니다.

  세마포어의 값이 0이고 잠들어 있는 프로세스가 있다면 세마포어의 값은 그대로 두고 잠들어 있는 프로세스를 하나 깨웁니다.

> down, up 연산에서 값을 검사하고 변경하고 잠드는 이러한 동작은 하나의 **원자적 행위**입니다.
>
> 한 번 시작 된 순간 다른 프로세스가 세마포어의 값에 접근할 수 없습니다.
>
> 이를 구현하기 위해 일반적으로 시스템 호출 형태로 구현하여 운영체제가 잠시 모든 인터럽트를 끄고 이루어집니다.
>
> 이 때 단순히 몇 개의 명령어로 가능하기 때문에 큰 문제가 되지 않습니다.



### 세마포어를 이용한 생산자 소비자 문제 해결 

세마포어를 이용하여 생산자 소비자 문제를 해결해봅시다.

이를 위해 3개의 세마포어가 필요합니다.

* full : 채워진 슬롯의 수, 0으로 초기화
* empty : 비어있는 슬롯의 수, 버퍼의 크기로 초기화
* mutex : 생산자와 소비자가 동시에 버퍼에 접근하지 못하도록 하는 변수, 1로 초기화

> 위 3개 중에 mutex 처럼 한 프로세스만 임계구역에 진입하도록 하는 세마포어를 이진 세마포어라고 합니다.



``` C
#define N 100
typedef int semaphore;
semaphore mutex = 1;
semaphore empty = N;
semaphore full = 0;

void producer(void)
{
  int item;
  
  while(true){
    item = produce_item();
    down(&empty);
    down(&mutex);
    insert_item(item);
    up(&mutex);
    up(&full);
  }
}

void consumer(void)
{
  int item;
  
  while(true){
		down(&full);
    down(&mutex);
    item = remove_item();
		up(&mutex);
    up(&empty);
    consume_item(item);
  } 
}
```



위에서 사용한 두 가지 종류의 세마포어에 대해 알아야합니다.

`mutex` 는 상호배제를 위한 용도로 사용되었고,

`full` , `empty` 는 버퍼가 가득 찬 경우 생산자가 정지하도록, 버퍼가 비어있는 경우 소비자가 정지하도록 하는 동기화의 목적으로 사용되었습니다.



### 뮤텍스

세마포어의 개수를 세는 능력이 필요 없는 경우 **뮤텍스**라 불리는 세마포어의 단순한 버전을 사용할 수 있습니다.

뮤텍스는 변수로서 unlock과 lock 두 가지 중 한 상태를 가집니다.

임계구역에 접근할 때 mutex_lock을 호출하고 나올 때 mutex_unlock을 호출합니다.

mutex_lock  호출 시 뮤텍스가 unlock이면 임계구역으로 진입이 가능합니다.

```
mutex_lock:
	TSL REGISTER, MUTEX
	CMP REGISTER, #0
	JZE ok
	CALL thread_yield
	JMP mutext_lock
	RET
ok:

mutex_unlock:
	MOVE MUTEX, #0
	RET
```



이는 바쁜 대기와 엄연히 차이를 보입니다. 

락을 획득하지 못하면 `CALL thread_yield`을 통해 CPU를 양보하고 다시 수행되었을 때 락을 다시 검사, `JMP mutext_lock`합니다.



## 레퍼런스

* 운영체제론

## 질문할 사항



## 추가 공부할 키워드

