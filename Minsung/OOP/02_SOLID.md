# 02. SOLID

## SOLID

SOLID는 객체지향 프로그래밍  및 설계 5대 원리의 앞글자를 따서 붙인 말입니다.

### 단일 책임 원칙(Single Responsibility Principle)

* 한 클래스는 하나의 책임만 가져야한다.
* 어떤 변화에 의해 클래스를 변경해야 하는 이유는 오직 하나

* 하나의 책임은 클수도, 작을 수도 있어서 모호하지만 중요한 기준은 **변경**

* 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것



### 개방 폐쇄 원칙(Open/Close Principle)

* 소프트웨어 구성요소(컴포넌트, 클래스, 모듈, 함수)는 확장에는 열려있으나, 변경에는 닫혀있어야 한다
* 요구사항의 변경이나 추가사항이 발생하더라도 기존 구성요소는 수정이 일어나지 말아야하며 기존 구성요소를 쉽게 확장해서 재사용할 수 있어야 한다는 뜻
* 이를 가능케 하는 중요 매커니즘이 추상화와 다형성

* 인터페이스를 구현한 새로운 클래스를 하나 만드는 것은 기존 코드를 변경하지 않고 확장하는 좋은 예제



### 리스코프 치환 원칙(Liskov Substitution Principle)

* 서브타입은 언제나 기반타입으로 교체 할 수 있어야한다

* 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위타입의 인스턴스로 바꿀 수 있어야한다.

* 단순히 컴파일에 성공하는 것을 넘어서는 이야기

* ex) 자동차 인터페이스의 엑셀은 앞으로 가는 기능, 뒤로 가게 구현하는 LSP 위반



### 인터페이스 분리 원칙(Interface Segregation Principle)   

* 자신이 사용하지 않는 인터페이스는 구현하지 말아야한다
* 하나의 일반적인 인터페이스보다는 여러 개의 구체적인 인터페이스가 낫다
* 만약 어떤 클래스를 이용하는 클라이언트가 여러 개고 이들이 해당 클래스의 특정 부분집합만을 이용한다면 이들을 따로 인터페이스로 빼내어 클라이언트가 기대하는 메시지만을 전달할 수 있도록 한다





### 의존관계 역전 원칙(Dependency Inversion Principle)

* 객체 사이에 서로 도움을 주고 받으며 의존 관계가 발생하는데 이 때 변화하기 쉬운 것보다 변화하기 어려운 것에 의존하라는 원칙
* 구현 클래스(변화하기 쉬운 것)에 의존하지 말고 인터페이스(변화하기  어려운 것)에 의존
* **의존성 주입**은 이 원칙을 따르는 방법 중 하나





## 레퍼런스

* https://www.nextree.co.kr/p6960/
* https://defacto-standard.tistory.com/113

## 질문할 사항



## 추가 공부할 키워드

