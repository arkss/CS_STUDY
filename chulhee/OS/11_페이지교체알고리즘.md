# 10. 페이지 교체 알고리즘

페이지 교체 알고리즘은 새롭게 적재될 페이지를 위해 메인 메모리 공간의 확보를 위해

현재 메인 메모리 위 페이지 중 어떤 페이지를 가상 메모리로 보낼 것인지 결정합니다.



과거에 참조되었거나,

현재 참조되고 있거나,

미래에 참조될 페이지들에 대해서 다양한 기법이 존재하게 됩니다.





## 1. FIFO 알고리즘

**페이지가 메인 메모리에 들어오는 시간을 기억**

페이지가 교체될 필요가 있을 때, 가장 먼저 들어온 페이지를 교체시키는 기법입니다.



### 장점

- 쉽고 설계가 간단합니다.

### 단점

- 메인메모리에 오래 있었다고 해서 교체되어 비효율적일 수 있습니다.
- FIFO 방식에서 프레임 수가 늘어나도 페이지 부재가 증가하는 경우가 발생할 수 있습니다.
  - 일반적으로 프레임 수가 증가하면 페이지 부재가 감소하지만 FIFO는 그렇지 않은 경우가 발생하기도 합니다.



## 2. 최적 교체 알고리즘 (Optimal Replacement)

>  최적의 실행을 얻기 위해서, 가장 오랫동안 사용되지 않을 페이지를 교체하는 알고리즘

FIFO 의 모순을 피하기 위한 알고리즘이며, 페이지 부재율을 최소로 가질 수 있습니다.

- 현실적으로 불가능

페이지 호출 순서에 대한 모든 상황을 파악하고 있어야 하기에 비현실적입니다.



## 3. LRU 알고리즘

> 최근에 사용하지 않은 페이지를 제거하는 알고리즘

타임 스탬프용 카운터나 스택을 두어 현 시점에서 가장 오래 전에 사용된 페이지를 제거하는 방법입니다.

카운터나 스택은 하드웨어에 해당하며, 이 알고리즘은 이 하드웨어가 필수적입니다.



*간단 정리*

- **카운터에 의한 방법**
  - 어떤 페이지에 대한 참조가 있을 때 그 시간 레지스터 내용은 페이지 테이블 내 사용시간 필드에 복사
  - 새로운 페이작 호출되면
    각 페이지 테이블 항목과 연관된 사용 시간 레지스터 값을 탐색하여 가장 작은 값을 가진 페이지와 교체
- **스택에 의한 방법**
  - 스택에 페이지 번호 수록
  - 페이지 호출될 때 스택의 꼭대기로 이동
  - 스택의 꼭대기에 있는 페이지가 가장 최근에 사용
  - 중간에서 페이지가 제거 및 탑(top)에 push 가능해야 하므로 **이중 연결 리스트 형태로 구현**





## 4. Second Chance(2차 기회) 알고리즘

>  하드웨어 지원이 반드시 요구되는 LRU 알고리즘 접근 방안으로 참조 비트를 이용하는 알고리즘
>
> FIFO 교체 알고리즘을 기본으로 사용

페이지 테이블의 각 항목에 한 개의 참조 비트를 연관시킵니다.
참조 비트 값으로 페이지의 사용여부를 알 수 있습니다.

- 참조 비트 값이 0 이면 페이지 교체
- 1이면 2차 기회를 줍니다
  - 2번째 기회가 주어져 다시 큐에 삽입되게 됩니다.





## 5. LFU(Least Frequently Used) 알고리즘

LRU 방법과 유사한 알고리즘입니다. 

가장 적게 사용되거나 집중적이지 않은 페이지가 교체 됩니다.

다만, 처음에 많이 사용되거나 나중에 사용되지 않는 페이지는 계속 메모리에 남게되는 단점이 있습니다.

이 문제는 MFU (Most Frequently Used) 알고리즘에 의 해결됩니다.



## 6. NUR(Not Used Recently) 알고리즘

최근에 사용하지 않은 페이지를 교체하는 알고리즘입니다.

최근에 사용 여부를 확인하기 위해 참조 비트와 변형 비트를 사용합니다.

- 참조 비트 : 페이지가 참조되지 않았을때는 0, 호출되었을때는 1로 지정
- 변형 비트 : 페이지 내용이 변경되지 않았을때는 0, 변경되었을때는 1로 지정

- 참조 X, 수정 X
- 참조 X, 수정 O
- 참조 O, 수정 X
- 참조 O, 수정 O

위에서부터 아래로 우선순위를 가집니다.



## 레퍼런스

- 박규석 외 3명, 운영체제, 생능출판, 4장 가상 메모리

