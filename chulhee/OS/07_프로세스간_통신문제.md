# 07. 프로세스 간 통신 문제



프로세간 통신의 중요한 점은

- 프로세스 사이 정보를 어떻게 전달할 것인지,
- 다수의 프로세스 통신에서 임계 구역에서 어떻게 행동할 것인지



## 1. 생산자 소비자 문제 (Producer-Consumer Problem)

데이터를 생산하면 소비자는 그 데이터를 소비하는 형태의 문제를 말합니다.

생산자가 생산한 데이터 양을 소비자가 한 번에 소비하는 경우는 매우 적습니다.

중간에 buffer를 두고 소비자는 필요한 만큼 가져가게 됩니다.

- 생산자는 버퍼가 가득 차면 더이상 저장할 수 없음
- 소비자는 버퍼가 비면 더이상 가져올 수 없음

이러한 유한한 크기의 버퍼를 **bounded buffer** 라고 합니다.

두 프로세스 생산자와 소비자가 동시에 buffer에 접근할 경우 
임계 구역에 동시에 접근하여 동기화 문제가 발생하게 됩니다.



### 해결방법

지난 챕터에서 작성했던 **세마포어**를 사용하여 상호배제를 보장해줄 수 있습니다.

바쁜 대기를 활용하여 버퍼가 가득 찼는지, 비었는지 무한 반복을 통해 상호배제를 구현할 수 있지만 
아무 일도 하지 않을 때도 무한으로 반복하여 CPU 점유할 경우 매우 비효율적입니다.

버퍼가 비어있는 공간의 개수 ```empty``` 와 ```full```을 사용하여 바쁜 대기를 해결해 줄 수 있습니다.

```java
class Buffer {
	int[] buf;
	int size;
	int count;
	int in;
	int out;
	Semaphore mutex, full, empty;

	Buffer(int size) {
		buf = new int[size];
		this.size = size;
		count = in = out = 0;
		mutex = new Semaphore(1);
		full = new Semaphore(0);
		empty = new Semaphore(size);
	}

	void insert(int item) {
		try {
            empty.acquire();    // 버퍼의 비어있는 공간을 1 감소(비어있는 공간 없으면 block)
            mutex.acquire();
            buf[in] = item;
            in = (in+1)%size;
            count++;
            mutex.release();
            full.release();    // 버퍼의 찬 공간을 1 증가시킨다.
          } catch(InterruptedException e) {}
	}

	int remove() {
		try {
            full.acquire();    // 버퍼의 찬 공간을 1 감소 (버퍼가 모두 비어있으면 block)
            mutex.acquire();
            int item = buf[out];
            out = (out+1)%size;
            count--;
            mutex.release();
            empty.release();   // 버퍼의 비어있는 공간을 1 증가시킨다.
            return item;
          } catch(InterruptedException e) {}
		return -1;
	}
}

// 출처 : https://velog.io/@codemcd/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-9.-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94-2
```

데이터를 생성하기 전, 버퍼에 빈 공간이 있는지 우선 확인합니다.

없다면 empty 세마포어의 값이 -1 이 되므로 block, 있다면 임계 구역으로 진입하여 데이터를 생성, 버퍼에 저장할 수 있습니다.

생성이 완료되면 full 세마포어의 값을 1 증가 시킵니다.





## 2. 읽는 자 쓰는 자 문제 (Readers-Writers Problem)

Readers-Writers 문제는 대표적으로 공통 데이터베이스에 접근하는 경우가 존재합니다.

하나의 데이터베이스에 여러 프로세스가 접근하므로, **데이터베이스는 임계구역으로 설정해야합니다.**

한 번에 하나의 프로세스만 접근가능하도록 해야하는데, 이는 정보를 조회하는 입장에서는 매우 비효율적입니다.

컨텍스트 스위칭에 관계없이 데이터의 일관성이 보장되기 때문입니다.

**따라서 접근하는 프로세스를 reader와 writer로 나누게 됩니다.**

- reader
  - 데이터베이스 정보를 읽기만 하는 프로세스
- writer
  - 정보를 바꾸는 프로세스

### 해결

reader 프로세스는 임계 구역에 동시접근이 가능하도록 하고,
writer 에만 상호배제를 적용하여 일관성을 유지할 수 있도록 합니다.





## 3. 식사하는 철학자 문제

> 철학자들이 원탁에 모여 식사를 합니다.
>
> 그들의 양쪽에 각각 젓가락 1개씩 놓여져 있고
> 양손에 젓가락를 한개씩 쥐면 일정 시간 동안 식사를 할 수 있습니다.
>
> 식사를 마치면 오른쪽 젓가락을 내려놓고, 그 다음 왼쪽 젓가락을 내려놓습니다.

이 문제는 **교착상태(Deadlock)**의 대표적인 예제입니다.

모든 철학자가 동시에 식사를 위해 왼쪽 젓가락을 집은 경우 남은 젓가락이 없기 때문에
누군가 젓가락을 내려놓기만을 기다리게 됩니다.

그렇기에 **기아 상태(Starvation)**에 빠지게 됩니다.



### 교착상태 - 데드락(Deadlock)

> 상호 배제에 의해 나타나는 문제점입니다.
>
> 둘 이상의 프로세스가 자원을 점유한 상태로 서로 다른 프로세스가 점유하고 있는 자원을 요구하며
> 무한정 기다리는 현상을 의미합니다.



### 교착상태 4가지 조건

- 상호배제
  - 젓가락은 한번에 한 철학자만 사용 가능
- 보유 및 대기
  - 집어든 젓가락을 계속 들은 채로 반대쪽 젓가락을 기다린다
- 비선점
  - 이미 누군가 쥐고있는 젓가락을 뺏을 수 없다
- 환형 대기
  - 모든 철학자는 자신의 오른쪽 철학자가 젓가락을 내려놓기를 기다린다



### 해결

위 문제에서 **철학자는 프로세스**, **젓가락**는 **자원**에 해당합니다.

위의 교착상태 4가지 조건 중 한가지만 성립하지 않도록 하면 교착상태 문제를 해결할 수 있습니다.



기본적으로 왼쪽을 먼저 들고 오른쪽을 드는 과정에서 문제가 발생하기에,
해당 과정에 대해서 수정하면 교착상태가 발생하지 않습니다.

> 짝수 번째 철학자는 왼쪽부터,
> 홀수 번째 철학자는 오른쪽부터 젓가락을 쥐게 됩니다.

환형 대기를 해결함으로써 이 문제를 해결할 수 있습니다.







## 레퍼런스

- [reader-writer problem ,philosopher problem - naver](https://m.blog.naver.com/hirit808/221786966867)
- [producer-consumer problem - velog](https://velog.io/@codemcd/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-9.-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94-2)
- 
- 





## 추가 공부 키워드

- 교착 상태





## 질문 사항

- reader -writer 문제에서 reader 프로세스가 많아지면 writer 프로세스는 starvation 에 빠지지 않나?