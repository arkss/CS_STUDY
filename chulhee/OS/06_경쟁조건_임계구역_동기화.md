# 06. 경쟁 조건, 임계 구역, 동기화



## 0. 운영체제에 대해서...

운영체제에 있어서 가장 중요한 두 가지를 꼽는다면

- CPU 스케줄링
- 프로세스 관리

라고 할 수 있습니다.

프로세스를 관리하지 못한다면,
메모리에 2개 이상의 프로세스가 동시에 접근하여 문제가 생기거나,
무한히 대기하는 등 문제가 발생할 수 있습니다.

이러한 부분에 대해 한 번 알아봅시다.



## 1. 프로세스/스레드 동기화

프로세스 동기화란 여러 프로세스가 **공유하는 자원의 일관성을 유지**하는 것입니다.
여러 프로세스가 동시에 하나의 공유된 자원에 접근하려고 할 때
이 프로세스들의 순서를 정하여 데이터의 일관성을 유지시켜줘야 합니다.



### 경쟁 상태

만일 두 개의 프로세스가 동시에 어떤 변수의 값을 바꿀 때
**프로세스의 접근 순서에 따라 결과 값이 달라질 수 있는 상황을 경쟁 상태(Race Condition)** 이라고 합니다.



### 은행 계좌 문제

동기화 문제 중에서 대표적인 경쟁 상태인 은행 계좌 문제 입니다.

가장 단순한 형태의 입출금 상황을 가정하겠습니다. 
은행에는 한 개의 계좌에 입금과 출금이 가능합니다.

**공유 자원** : 계좌

스레드 : 입금, 출금

자바로 작성된 코드는 [velog/@codemcd](https://velog.io/@codemcd/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-8.-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94-1#:~:text=%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20%EB%8F%99%EA%B8%B0%ED%99%94%EB%8A%94%20%EC%97%AC%EB%9F%AC%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4,%EC%9D%84%20%EC%9C%A0%EC%A7%80%EC%8B%9C%EC%BC%9C%EC%A3%BC%EC%96%B4%EC%95%BC%20%ED%95%9C%EB%8B%A4.) 블로그에 잘 나와있습니다.



동일한 양의 입출금이 일어난 이후 계좌 잔고가 0 이 아닌 값을 가지는 결과가 생깁니다.

이는 여러 스레드가 하나의 공유자원을 사용하는 동안 동기화 문제가 발생했기 때문입니다.



### 임계 구역

이런 경쟁 조건이 발생하지 않기 위해서는 한 번에 하나의 스레드만 메모리에 접근해야합니다.
이를 위해 임계 구역이라는 구역을 정의하게 됩니다.

> 여러 개의 스레드가 수행되는 시스템에서 각 쓰레드가 **공유하는 데이터(변수, 테이블, 파일 등)를 변경하는 코드 영역**

즉, 공유된 자원에 접근하기 위해선 임계 구역에 진입해야 합니다.

이러한 임계 구역 문제를 해결하기 위해선 3가지 조건을 충족해야 합니다.

- **상호 배제 (Mutual Exclusion)**
  - 한 번에 2개 이상의 스레드가 접근할 수 없습니다.
- **진행 (Progress)**
  - 임계영역에 어떤 스레드의 접근이 없을 때는 항상 접근이 가능합니다.
- **한정 대기 (Bounded waiting)**
  - 자원을 요청한 스레드가 무한정 대기하지 않고 임계 구역으로 진입할 수 있습니다.



#### 상호 배제 구현 방법

인터럽트 끄기, 락 변수, 엄격한 교대, Peterson 해법, TLS 명령 등이 있습니다.

- **인터럽트 끄기**
  - 각 프로세스가 임계구역에 진입하자마자 인터럽트를 끄고 
    임계구역에서 나가기 직전에 인터럽트를 켜도록 하는 방식
  - **문제점** 
    - 사용자 프로세스에게 인터럽트를 끌 수 있는 권한을 주는 것은 좋지 않습니다.
      인터럽트가 다시 켜지지 않을 수 있습니다.
    - 프로세스가 임계 구역을 떠나면서 인터럽트를 불가능하게 하는 경우
      다수의 CPU 환경에서 하나가 인터럽트가 금지되어도 다른 CPU는 가능합니다.



- **락(Lock) 변수**
  - 락 변수를 사용하여 해결하는 소프트웨어적 방법입니다.
  - 초기 값을 0으로 지정.
    임계 구역에 들어갈 때 1로 설정, 나올 때 0으로 설정하는 방법입니다.
  - **문제점**
    - 변수가 1로 설정되기 전, 동시에 두 프로세스가 임계구역에 진입하는 경우가 있을 수 잇습니다.





- **엄격한 교대**

  - 2 개 이상의 프로세스가 교대로 공유 자원을 점유하는 방법입니다.
  - 공유 변수 turn 값을 기준으로 임계 구역에 들어갈지를 결정하게 됩니다.

  ```c
  // process - a 
  while (true){
    while (turn != 0)
      critical_region();
      turn = 1;
  	noncritical_region();
  }

  // process - b
while (true){
    while (turn != 1)
      critical_region();
      turn = 0;
    	noncritical_region();
  }
  ```
  
  - a 프로세스는 turn 값을 기준으로 0이 될 때까지 무한루프를 돌아 turn 값이 0 이되면 다른 프로세스가 사용할 수 있도록 1로 바꿔주고 나오게 됩니다.
    - b 도 마찬가지
  - **문제점**
    - 두 프로세스의 속도 차이가 클 경우 짧은 수행시간을 갖는 한 프로세스는 매번 오랜 시간 기다리게 됩니다.
    - Progress 조건 또한 만족할 수 없습니다.
      a 프로세스가 임계 구역에 들어갔다가 나올 때 turn 값이 1이 되면
      b 프로세스가 작업을 하지 않더라도 a 프로세스는 임계구역에 들어갈 수 없습니다.



- **Peterson 해법**

```c
// 전역 변수
static bool flag[2] = {false,false};
static int turn = -1;

while (true) {
  flag[i] = TRUE;
  turn = j;
  while ( flag[j] && turn == j);
	  //CRITICAL SECTION
  flag[i] = FALSE;
  //REMAINDER SECTION
}
// [출처] [os] 피터슨의 풀이(Peterson's Solution)|작성자 IGAAAAA
```

- 2개의 프로세스에 대해서 가능한 해법입니다.
- 위와 마찬가지, 바쁜 대기를 수행합니다.
- 엄격한 교대와 달리 flag 값은 임계 구역에서 할 작업이 생기면 ```flag[i] = TRUE``` 를 통해 progress 조건도 만족합니다.

- **문제점** 
  - 참여하는 프로세스가 2개인 경우만 고려합니다.
  - (3개 이상의 프로세스가 참여하는 환경에선 별도의 버퍼를 두거나 대기 시간에 따른 우선도를 주는 스케줄링 방법 등을 통해 구현할 수 있습니다.)



### 세마포어 (Semaphore)

공유된 자원의 데이터를 **여러 프로세스가** 접근하는 것을 막는 것입니다.

프로세스 간 상호배제와 동기화를 위한 연산이 필요하게 되고 세마포어는 여러 프로세스들에 의해 공유되는 변수로 정의됩니다.

자원에 접근할 수 없도록 블럭을 하고 
이 값이 0보다 크면 
접근함과 동시에 값을 1 감소시킵니다. 

반대로 종료하고 나갈 때에는 
세마포어의 값을 1 증가시켜 다른 프로세스가 접근할 수 있도록 합니다.







#### 세마포어 접근 함수 - wait(), signal()

세마포어 변수는 wait() 과 signal() 함수로만 접근 가능한 정수 타입의 변수입니다.

- **wait()** 
  - 세마포어 값을 감소시키고.
    이 값이 0 보다 작으면 임계구역에 프로세스가 이미 존재
  - 다른 프로세스는 접근할 수 없습니다.
  - 아래 코드에서 acquire 로 구현되어있습니다.
- **signal()**
  - 세마포어값을 증가시키고,
    0보다 크거나 같으면 임계구역에 진입하려고 대기하는 프로세스가 존재
  - 그 중 하나를 임계구역을 수행할 수 있도록 해줄 수 있습니다.
  - 아래 코드에서 release 로 구현되어있습니다.

```java
class Semaphore {
  int value;      // number of permits
  Semaphore(int value) {
    // ...
  }
  void acquire() {
    value--;
    if (value < 0) {
      // add this process/thread to list
      // block
    }
  }
  void release() {
    value++;
    if (value <= 0) {
      // remove a process P from list
      // wakeup P
    }
  }
}

// 출처 : https://velog.io/@codemcd/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-8.-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94-1#:~:text=%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20%EB%8F%99%EA%B8%B0%ED%99%94%EB%8A%94%20%EC%97%AC%EB%9F%AC%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4,%EC%9D%84%20%EC%9C%A0%EC%A7%80%EC%8B%9C%EC%BC%9C%EC%A3%BC%EC%96%B4%EC%95%BC%20%ED%95%9C%EB%8B%A4.
```





### 뮤텍스

- 공유된 자원의 데이터를 **여러 스레드가** 접근하는 것을 막는 것입니다.









## 레퍼런스

- [프로세스 동기화 velog.io/@codemcd](https://velog.io/@codemcd/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-8.-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94-1#:~:text=%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20%EB%8F%99%EA%B8%B0%ED%99%94%EB%8A%94%20%EC%97%AC%EB%9F%AC%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4,%EC%9D%84%20%EC%9C%A0%EC%A7%80%EC%8B%9C%EC%BC%9C%EC%A3%BC%EC%96%B4%EC%95%BC%20%ED%95%9C%EB%8B%A4)
- [세마포어 https://jhnyang.tistory.com/101](https://jhnyang.tistory.com/101)

- [상호배제 구현 방법 https://worthpreading.tistory.com/20](https://worthpreading.tistory.com/20)
- [피터슨의 풀이 http://blog.naver.com/PostView.nhn?blogId=lighting12&logNo=221001280768](http://blog.naver.com/PostView.nhn?blogId=lighting12&logNo=221001280768)





## 추가 공부할 키워드

- 세마포어 vs 뮤텍스
- 



## 질문할 사항 

