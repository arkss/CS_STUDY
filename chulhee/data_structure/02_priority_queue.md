# 02. 우선 순위 큐



일반적인 큐는 FIFO 구조를 갖고 있습니다.

하지만 우선순위 큐는 들어간 순서에 관계없이 우선순위가 높은 데이터가 먼저 나오는 것을 말합니다.

이러한 우선순위 큐는 힙(Heap) 이라는 자료구조를 통해 구현을 하게 됩니다.



## 1. 힙(Heap) 이란?

힙은 완전 이진 트리에 있는 노드 중 키 값이 가장 크거나 작은 노드를 찾기 위해 만든 자료구조 입니다.

- 최대 힙 (Max Heap)
  - 가장 큰 노드를 찾기 위한 힙
- 최소 힙 (Min Heap)
  - 가장 작은 노드를 찾기 위한 힙



### 최대 힙

최대 힙을 기준으로 설명해보겠습니다.

최대 힙은 부모 노드의 키 값이 자식 노드의 키 값보다 항상 크거나 같은 크기의 관계입니다.
즉, **루트 노드의 값이 가장 큰 완전 이진 트리**라고 할 수 있습니다.

일반적으로 힙은 최대 힙을 의미하며, 같은 키 값의 노드의 중복을 허용합니다.



### 연산

#### 삽입 연산

1. 완전 이진 트리의 형태를 유지하기 위해서 
   현재의 마지막 노드의 다음 자리를 만들고, 삽입할 노드를 임시로 저장합니다.

2. 부모 노드와 그 값을 비교하여, 부모 노드 값 < 자식 노드 이면 서로 자리를 바꾸어 줍니다.
3. 이를 만족할 때까지 삽입할 위치를 찾아서 최대 힙을 재구성 합니다.



#### 삭제 연산

삭제 연산은 언제나 루트 노드의 원소를 삭제하여 리턴해줍니다. -> 우선순위가 가장 높은 노드

루트 노드가 삭제되면서 완전 이진 트리의 형태를 유지해야 하기 때문에,
마지막 노드를 루트 노드로 임시로 옮깁니다.

이후 최대 힙이 되도록 조정하는 과정을 거쳐주면됩니다.

```c
int delete(int *n){
  int first, temp, parent, child;

  first = heap[1];
	temp = heap[(*n)--];
	parent = 1;
	child = 2;

	while (child <= *n) {
		if ((child < *n) && (heap[child] > heap[child + 1]))
			child++;

		if (temp <= heap[child])
			break;

		heap[parent] = heap[child];
		parent = child;
		child *= 2;
	}

	heap[parent] = temp;
	return first;
}
```



## 그래서 우선순위 큐를 왜 힙으로 하는데?

이제 힙에 대한 이해를 기반으로 우선 순위 큐를 사용할 때 힙을 사용하는 이유는 알 것 같습니다.

그렇다면 배열이나 연결리스트로는 하지 않는 이유는 무엇일까요?

### 배열로 했을 경우

우선 순위가 높은 순서대로 배열의 앞부분부터 넣을 경우 우선순위가 높은 데이터를 리턴하기 매우 쉽습니다.

하지만, 중간 정도의 우선순위를 갖는 데이터가 삽입된다면, 뒤의 데이터를 모두 index를 한 칸씩 밀어야합니다.

또한, 삽입 위치를 탐색하기 위해 최악의 경우 모든 인덱스를 탐색해야 합니다.

삭제 시 시간 복잡도 : O(1)

삽입 시 최악 시간 복잡도 : O(n)



### 연결리스트로 구현한 경우

마찬가지로, 삽입의 경우 모두 탐색해야하기 때문에 최악의 경우 O(n) 이라는 시간 복잡도를 갖게 됩니다.



### 힙은?

삭제나 삽입의 과정에서 보았듯이, 모든 노드의 탐색을 하지 않고 부모와 자식 노드의 비교만 일어나게 됩니다.

따라서 삽입과 삭제 모두 시간 복잡도는 O(log n) 정도를 갖게 됩니다.

삭제에선 배열과 연결리스트가 우위를 점해도, 전반적으로 힙이 더 강점을 갖기에 힙으로 구현하게 됩니다.





## 레퍼런스

- https://chanhuiseok.github.io/posts/ds-4/
- 자바로 배우는 쉬운 자료구조, 한빛아카데미





